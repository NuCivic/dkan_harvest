<?php
/**
 * @file
 * Code for the DKAN Harvest Sources feature.
 */

include_once 'dkan_harvest_sources.features.inc';

/**
 * Allowed values for field_dkan_harveset_type field.
 *
 * Re-wrap the dkan_harvest_source_types_definition function to return only the
 * needed source types.
 */
function dkan_harvest_sources_field_dkan_harveset_type_allowed_values() {
  // We only need the machine_names for the source types.
  $allowed_values = array();
  $source_types_definition = dkan_harvest_source_types_definition();
  foreach ($source_types_definition as $source_type) {
    $allowed_values[$source_type->machine_name] = $source_type->label;
  }

  return $allowed_values;
}

/**
 * Implements hook_field_attach_validate().
 */
function dkan_harvest_sources_field_attach_validate($entity_type, $entity, &$errors) {
  if ($entity_type == 'node' && $entity->type == 'harvest_source') {
    // Validation for the field_dkan_harvest_source_uri field.
    if (isset($entity->field_dkan_harvest_source_uri)) {
      foreach ($entity->field_dkan_harvest_source_uri as $langcode => $field_value_multiple) {
        foreach ($field_value_multiple as $delta => $field_value_single) {
          $uri = $field_value_single['value'];
          dkan_harvest_sources_field_attach_validate_source_uri($uri, $langcode, $delta, $errors);
        }
      }
    }
  }
}

/**
 * Validation for the field_dkan_harvest_source_uri.
 *
 * @param $uri: uri property for the field value.
 * @param $langcode Language code for field value.
 * @param $delta field delta.
 * @param $errors reference errors array pass from the hook_field_attach_validate().
 */
function dkan_harvest_sources_field_attach_validate_source_uri($uri, $langcode, $delta, &$errors) {
  $matches = array();
  $allowed_protocols = array('http://', 'https://', 'file://', 'public://', 'private://');
  $pattern = '%^(' . implode('|', $allowed_protocols) . ')%';
  if (preg_match($pattern, $uri, $matches)) {
    switch (array_pop($matches)) {
      // Validate local uri
      case 'file://':
      case 'public://':
      case 'private://':
        if (!file_exists($uri)) {
          $errors['field_dkan_harvest_source_uri'][$langcode][$delta][] = array(
            'error' => 'dkan_harvest_sources_uri_invalid',
            'message' => t('Source local URI does not exists!'),
          );
        }
        break;
      // Validate remote uri
      case 'http://':
      case 'https://':
        if (!filter_var($uri, FILTER_VALIDATE_URL)) {
          $errors['field_dkan_harvest_source_uri'][$langcode][$delta][] = array(
            'error' => 'dkan_harvest_sources_uri_invalid',
            'message' => t('Source remote URI invalid!'),
          );
        }
        break;
      default:
        // In theory this should not happen and we should have all the allowed
        // protocols specific validation covered. Return a generic error.
        $errors['field_dkan_harvest_source_uri'][$langcode][$delta][] = array(
          'error' => 'dkan_harvest_sources_uri_invalid',
          'message' => t('Source URI invalid!'),
        );
    }
  }
  else {
    // URI does not match the allowed protocols regex.
    $errors['field_dkan_harvest_source_uri'][$langcode][$delta][] = array(
      'error' => 'dkan_harvest_sources_uri_not_allowed',
      'message' => t('Source URI protocol not allowed! Allowed protocols are %allowed_protocols',
      array('%allowed_protocols' => implode(', ', $allowed_protocols))),
    );
  }
}
